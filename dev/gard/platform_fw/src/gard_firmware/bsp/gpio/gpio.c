/*   ==================================================================

	 >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
	 ------------------------------------------------------------------
	 Copyright (c) 2019-2025 by Lattice Semiconductor Corporation
	 ALL RIGHTS RESERVED
	 ------------------------------------------------------------------

	   IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
	   DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

	   Lattice grants permission to use this code pursuant to the
	   terms of the Lattice Propel License Agreement.

	 DISCLAIMER:

	LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
	WHETHER EXPRESSED, IMPLIED, STATUTORY,
	OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
	COMMUNICATION WITH LICENSEE,
	AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
	MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
	LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
	LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
	SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
	UNINTERRUPTED OR ERROR FREE,
	OR THAT DEFECTS HEREIN WILL BE CORRECTED.
	LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
	ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
	AND RESULTS OBTAINED THEREFROM.
	LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
	DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
	LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
	CORRECTION,
	OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
	SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
	INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
	INCLUDING LOST PROFITS,
	ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
	EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
	LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
	IS SET FORTH ABOVE.
	LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
	ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
	INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
	RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
	FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
	 ------------------------------------------------------------------

	 ================================================================== */

#include "gard_types.h"
#include "assert.h"
#include "gpio.h"
#include "gpio_regs.h"
#include "utils.h"

/**
 * gpio_pins_init() initializes local data structure used to access the GPIO
 * instance at base_addr. The function also configures the direction of the GPIO
 * pins as specified by gpio_dirs.
 *
 * @param this_gpio points to the GPIO instance to be initialized.
 * @param base_addr is the base address of the GPIO instance.
 * @param lines_num is the number of GPIO lines to be configured.
 * @param gpio_dirs is a bit mask that specifies the direction of each GPIO pin.
 *
 * @return None.
 */
void gpio_pins_init(struct gpio_instance *this_gpio,
					uint32_t              base_addr,
					uint32_t              lines_num,
					uint32_t              gpio_dirs)
{
	unsigned int index = 0;
	uint32_t     gpio_pin_mask;

	GARD__DBG_ASSERT((NULL != this_gpio) && (lines_num <= MAX_NUMBER_OF_GPIO),
					 "Invalid GPIO instance or number of lines");

	this_gpio->base_address = base_addr;

	for (index = 0; index < lines_num; index++) {
		/* Determines the mask value for indexed GPIO pin */
		gpio_pin_mask = 0x01 << index;

		if (gpio_dirs & (GPIO_OUTPUT << index)) {
			GARD__SET_BITS(*(volatile uint32_t *)(this_gpio->base_address +
												  GPIO_DIRECTION),
						   gpio_pin_mask);
		} else {
			GARD__RESET_BITS(*(volatile uint32_t *)(this_gpio->base_address +
													GPIO_DIRECTION),
							 gpio_pin_mask);
		}
	}
}

/**
 * gpio_pin_set_dir() sets the direction of the specified GPIO pin as input or
 * output.
 *
 * @param this_gpio points to the GPIO instance.
 * @param pin whose direction is to be set.
 * @param gpio_dir specifies the direction of the GPIO pin, either GPIO_INPUT or
 * 				   GPIO_OUTPUT.
 *
 * @return None.
 */
void gpio_pin_set_dir(struct gpio_instance *this_gpio,
					  uint32_t              pin,
					  enum gpio_direction   gpio_dir)
{
	uint32_t gpio_pin_mask;

	GARD__DBG_ASSERT(
		(NULL != this_gpio) && (pin < MAX_NUMBER_OF_GPIO) &&
			((GPIO_INPUT == gpio_dir) || (GPIO_OUTPUT == gpio_dir)),
		"Invalid parameter provided to gpio_pin_set_dir");

	gpio_pin_mask = 0x01 << pin;

	if (GPIO_INPUT == gpio_dir) {
		GARD__RESET_BITS(
			*(volatile uint32_t *)(this_gpio->base_address + GPIO_DIRECTION),
			gpio_pin_mask);
	} else {
		GARD__SET_BITS(
			*(volatile uint32_t *)(this_gpio->base_address + GPIO_DIRECTION),
			gpio_pin_mask);
	}
}

/**
 * gpio_pin_write() sets the output value of the specified GPIO pin to high
 * or low.
 *
 * @param this_gpio points to the GPIO instance.
 * @param pin whose output value is to be set.
 * @param value specifies the output value of the GPIO pin, either
 * GPIO_OUTPUT_HIGH or GPIO_OUTPUT_LOW.
 *
 * @return None.
 */
void gpio_pin_write(struct gpio_instance *this_gpio,
					uint32_t              pin,
					uint32_t              value)
{
	uint32_t gpio_pin_mask;

	GARD__DBG_ASSERT(
		(NULL != this_gpio) && (pin < MAX_NUMBER_OF_GPIO) &&
			((GPIO_OUTPUT_HIGH == value) || (GPIO_OUTPUT_LOW == value)),
		"Invalid parameter provided to gpio_pin_write");

	gpio_pin_mask = 0x01 << pin;

	if (GPIO_OUTPUT_LOW == value) {
		GARD__RESET_BITS(
			*(volatile uint32_t *)(this_gpio->base_address + GPIO_WR_DATA),
			gpio_pin_mask);
	} else {
		GARD__SET_BITS(
			*(volatile uint32_t *)(this_gpio->base_address + GPIO_WR_DATA),
			gpio_pin_mask);
	}
}

/**
 * gpio_pin_read() reads the input value of the specified GPIO pin and returns
 * it to the caller.
 *
 * @param this_gpio points to the GPIO instance.
 * @param pin whose input value is to be read.
 *
 * @return 0 if pin is low or 1 if pin is high.
 */
uint32_t gpio_pin_read(struct gpio_instance *this_gpio, uint32_t pin)
{
	uint32_t gpio_pin_mask;
	uint32_t data;

	GARD__DBG_ASSERT((NULL != this_gpio) && (pin < MAX_NUMBER_OF_GPIO),
					 "Invalid parameter provided to gpio_pin_read");

	gpio_pin_mask = 0x01 << pin;

	data          = GARD__GET_BITS(
        *(volatile uint32_t *)(this_gpio->base_address + GPIO_RD_DATA),
        gpio_pin_mask);

	return ((data != 0) ? 1U : 0U);
}
