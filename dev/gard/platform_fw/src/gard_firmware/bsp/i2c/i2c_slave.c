/*
 *    ==================================================================
	 >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
	 ------------------------------------------------------------------
	 Copyright (c) 2006-2025 by Lattice Semiconductor Corporation
	 ALL RIGHTS RESERVED
	 ------------------------------------------------------------------

	 IMPORTANT: THIS FILE IS AUTO-GENERATED BY LATTICE RADIANT Software.

	 Permission:

	Lattice grants permission to use this code pursuant to the
	terms of the Lattice Corporation Open Source License Agreement.

	 Disclaimer:

	Lattice provides no warranty regarding the use or functionality
	of this code. It is the user's responsibility to verify the
	user Software design for consistency and functionality through
	the use of formal Software validation methods.

	 ------------------------------------------------------------------

	 Lattice Semiconductor Corporation
	 111 SW Fifth Avenue, Suite 700
	 Portland, OR 97204
	 U.S.A

	 Email: techsupport@latticesemi.com
	 Web: http://www.latticesemi.com/Home/Support/SubmitSupportTicket.aspx
	 ==================================================================
*/
#include "i2c_slave.h"
#include "i2c_slave_regs.h"
#include "assert.h"

/*
 ------------------------------------------------------
 -                                                    -
 - I2C Target Device Register-map                           -
 -                                                    -
 ------------------------------------------------------
 */
struct i2c_dev {
	volatile uint32_t rxtx;
	volatile uint32_t slave_addr_low;
	volatile uint32_t slave_addr_high;
	volatile uint32_t control;
	volatile uint32_t target_byte_count;
	volatile uint32_t int_status1;
	volatile uint32_t int_enable1;
	volatile uint32_t int_set1;
	volatile uint32_t int_status2;
	volatile uint32_t int_enable2;
	volatile uint32_t int_set2;
	volatile uint32_t fifo_status;
	volatile uint32_t rx_addr1;
	volatile uint32_t rx_addr2;
};

uint8_t i2c_slave_clk_stretch(struct i2c_slave_instance *this_i2cs,
							  uint8_t                    stretch_enable)
{
	struct i2c_dev *dev;

	GARD__DBG_ASSERT(NULL != this_i2cs, "i2c_slave_instance is NULL");

	dev = (struct i2c_dev *)(this_i2cs->base_addr);

	// Set the stretch enable bit based on the input parameter
	if (stretch_enable) {
		dev->control |= I2C_SLAVE_SCLK_STRETCH_EN;
	} else {
		dev->control &= ~I2C_SLAVE_SCLK_STRETCH_EN;
	}

	return I2C_SLV_SUCCESS;
}

/*
 ***************************************************************
 * Retrieves characters from i2c FIFO and places them in the buffer for count
 * bytes. The routine returns the number of characters read which could be less
 * than the requested count if there are not enough characters available in the
 * i2c FIFO.
 * Returns the number of characters read from i2c FIFO.
 ***************************************************************
 */
uint32_t i2c_getchars(void *handle, uint8_t *rx_buf, uint32_t length)
{
	struct i2c_slave_instance *this_i2cs = (struct i2c_slave_instance *)handle;
	struct i2c_dev            *dev;
	uint32_t                   bytes_read = 0;

	GARD__DBG_ASSERT((NULL != this_i2cs) && (0U != this_i2cs->base_addr) &&
						 (NULL != rx_buf),
					 "Invalid I2C parameters");

	if (0U == length) {
		return 0U;
	}

	dev = (struct i2c_dev *)(this_i2cs->base_addr);

	while (bytes_read < length &&
		   !(dev->fifo_status & I2C_SLAVE_RX_FIFO_EMPTY)) {
		rx_buf[bytes_read++] = dev->rxtx;
	}

	return bytes_read;
}

/*
 ***************************************************************
 * Sends characters to i2c FIFO to be sent to the i2c master.
 * The routine returns the number of characters sent which could be less
 * than the requested count if the FIFO reaches a full condition.
 * Returns the number of characters sent over i2c.
 ***************************************************************
 */
uint32_t i2c_putchars(void *handle, uint8_t *tx_buf, uint32_t length)
{
	struct i2c_slave_instance *this_i2cs = (struct i2c_slave_instance *)handle;
	struct i2c_dev            *dev;
	uint32_t                   bytes_sent = 0;

	GARD__DBG_ASSERT((NULL != this_i2cs) && (0U != this_i2cs->base_addr) &&
						 (NULL != tx_buf),
					 "Invalid I2C parameters");

	if (0U == length) {
		return 0U;
	}

	dev = (struct i2c_dev *)(this_i2cs->base_addr);

	while (bytes_sent < length &&
		   !(dev->fifo_status & I2C_SLAVE_TX_FIFO_FULL)) {
		dev->rxtx = tx_buf[bytes_sent++];
	}

	return bytes_sent;
}

uint8_t i2c_slave_init(struct i2c_slave_instance *this_i2cs,
					   uint32_t                   base_addr,
					   uint16_t                   slave_addr,
					   uint8_t                    addr_mode)
{
	GARD__DBG_ASSERT(NULL != this_i2cs, "i2c_slave_instance is NULL");

	this_i2cs->base_addr  = base_addr;
	this_i2cs->slave_addr = slave_addr;
	this_i2cs->addr_mode  = addr_mode;

	return I2C_SLV_SUCCESS;
}

uint8_t i2c_slave_config(struct i2c_slave_instance *this_i2cs)
{
	struct i2c_dev *dev;

	GARD__DBG_ASSERT(NULL != this_i2cs, "i2c_slave_instance is NULL");

	dev                    = (struct i2c_dev *)(this_i2cs->base_addr);

	dev->control           = this_i2cs->addr_mode;
	dev->slave_addr_low    = this_i2cs->slave_addr;
	dev->target_byte_count = 0;
	dev->int_enable1       = I2C_SLAVE_STOP_DET | I2C_SLAVE_RX_FIFO_READY |
					   I2C_SLAVE_RX_FIFO_AFULL | I2C_SLAVE_RX_FIFO_FULL;
	dev->int_enable2 = I2C_SLAVE_STOP_ERR | I2C_SLAVE_START_ERR;

	return I2C_SLV_SUCCESS;
}
