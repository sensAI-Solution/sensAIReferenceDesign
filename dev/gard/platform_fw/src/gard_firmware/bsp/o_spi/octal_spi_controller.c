/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2025-2025 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL™
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

================================================================== */

#include "octal_spi_controller.h"

unsigned int temp_read = 0;
octal_spi_op octal_spi_op_st;

/**
 * @brief 	Function to initializes the Octal SPI Controller IP.
 *
 * This API initializes the Octal SPI Controller IP with the following actions:
 * - Assigns the base address to the this_smbus_filter struct.
 * - Initializes the Octal IP configuration derived from the input pointer
 *   (refer to the spix8_ctl_handle_t struct).
 * - Enables the interrupt.
 *
 * @param 	handle	 			Pointer of Handle of the spix8_ctl_handle_t structure.
 * @param 	base_addr 			Base address to be assigned.
 * @param 	flash_addr_offset 	Target flash address offset.
 * @return 	                    Returns 'SUCCESS' (0) on success,
 * 							    or 'FAILURE' (1) if input pointer is NULL.
 */

unsigned char spix8_flash_ctl_init( spix8_ctl_handle_t *handle,
									unsigned int base_addr,
									unsigned int flash_addr_offset)
{
	unsigned char status = FAILURE;
	unsigned int rdat;

	if (!handle)
		return FAILURE;

	if(base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(base_addr);

		octal_spi_c0.min_tgtaddr_size = spix8_ctl->SPIX8_REG_MIN_TGT_SIZE;
		octal_spi_c0.tot_tgtaddr_size = spix8_ctl->SPIX8_REG_TOT_TGT_SIZE;

		/* Update Configuration 0 register */
		rdat = spix8_ctl->SPIX8_REG_CONFIG0;

		SET_REG_FIELD(rdat, handle->lsb_first, 1, SPIX8_CFG0_LSBF_IDX);
		SET_REG_FIELD(rdat, handle->spi_mode, 2, SPIX8_CFG0_CPHA_IDX);
		SET_REG_FIELD(rdat, handle->endianness, 1, SPIX8_CFG0_ENDIANNESS_IDX);
		SET_REG_FIELD(rdat, handle->en_tgtaddr_map, 1, SPIX8_CFG0_EN_ADDR_MAP_IDX);
		SET_REG_FIELD(rdat, handle->use_ds_in_ddr, 1, SPIX8_CFG0_USE_DS_IDX);
		SET_REG_FIELD(rdat, handle->non_block_txfifo, 1, SPIX8_CFG0_NONBLOCK_TXFIFO_IDX);
		SET_REG_FIELD(rdat, handle->non_block_rxfifo, 1, SPIX8_CFG0_NONBLOCK_RXFIFO_IDX);
		SET_REG_FIELD(rdat, handle->autoclr_txstart, 1, SPIX8_CFG0_AUTOCLR_TXSTART_IDX);
		SET_REG_FIELD(rdat, handle->autoclr_softrst, 1, SPIX8_CFG0_AUTOCLR_SOFTRST_IDX);
		SET_REG_FIELD(rdat, handle->sck_rate, 5, SPIX8_CFG0_SCK_RATE_IDX);

		spix8_ctl->SPIX8_REG_CONFIG0 = rdat;
		spix8_ctl->SPIX8_REG_TGT_ADDROFST = flash_addr_offset;
		spix8_ctl->SPIX8_REG_INT_ENABLE = handle->interrupt_enable;
		handle->min_tgtaddr_size = spix8_ctl->SPIX8_REG_MIN_TGT_SIZE;
		handle->tot_tgtaddr_size = spix8_ctl->SPIX8_REG_TOT_TGT_SIZE;

		status = SUCCESS;
	}

	return status;
}

/**
 * @brief Private/Internal Sets the operational parameters for the Octal SPI controller.
 *
 * This function configures the operational parameters for the Octal SPI
 * controller by setting the command, widths, IO rates, and dummy cycles.
 *
 * @param params       A pointer to a struct containing all operational parameters.
 */

void set_op_param(const op_param_t *params)
{
	octal_spi_op_st.command = params->command;
	octal_spi_op_st.cmd_width = params->cmd_width;
	octal_spi_op_st.data_width = params->data_width;
	octal_spi_op_st.adr_width = params->adr_width;
	octal_spi_op_st.cmd_io_rate = params->cmd_io_rate;
	octal_spi_op_st.data_io_rate = params->data_io_rate;
	octal_spi_op_st.adr_io_rate = params->adr_io_rate;
	octal_spi_op_st.dummy_cycle = params->dummy_cycle;
}

/**
 * @brief 	Private/Internal function to perform the I/O width mapping.
 *
 * This API is used to perform the I/O width mapping.
 *
 * @param 	io_width	 Input io width to be program into SPI flash
 * @return 	             Returns 'SUCCESS' (0) on success,
 * 					     or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char encode_spi_io_width(unsigned int io_width)
{
	unsigned int enc_io_width;

	enc_io_width = (io_width == SPIX8_IO_X1_X1_X1)? 0x0 :
				(io_width == SPIX8_IO_X2_X2_X2)? 0x1 :
				(io_width == SPIX8_IO_X4_X4_X4)? 0x2 :
				(io_width == SPIX8_IO_X8_X8_X8)? 0x3 :
				(io_width == SPIX8_IO_X1_X1_X2)? 0x4 :
				(io_width == SPIX8_IO_X1_X2_X2)? 0x5 :
				(io_width == SPIX8_IO_X1_X1_X4)? 0x8 :
				(io_width == SPIX8_IO_X1_X4_X4)? 0x9 :
				(io_width == SPIX8_IO_X1_X1_X8)? 0xC :
				(io_width == SPIX8_IO_X1_X8_X8)? 0xD : 0x0;

	return enc_io_width;
}

/**
 * @brief 	Private/Internal function to poll the SPI status by reading the octal SPI debug
 *          information 0 register
 *
 * This API is used to poll the SPI status by reading the octal SPI debug
 * information 0 register (offset 0x10C).
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	wait_value	     Expected value for SPI busy status done
 * @param 	expect_started	 Flag to indicate that polling has started
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char wait_spi_ctl_busy_status(spix8_ctl_handle_t *handle,
									unsigned int wait_value,
									unsigned int expect_started)
{
	unsigned char status = FAILURE;
	unsigned int spi_busy;
	unsigned int spi_has_started;
	unsigned int wait_done;
	volatile unsigned int rdat;

	if (!handle)
		return FAILURE;

	if (handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(handle->base_addr);

		wait_done         = 0;
		spi_busy          = 0;
		spi_has_started   = 0;

	do {
		rdat = spix8_ctl->SPIX8_REG_DEBUG_INFO0;
		spi_busy = rdat & SPIX8_DEBUG0_SPI_BUSY;
		spi_has_started = (rdat & SPIX8_DEBUG0_SPI_STARTED) | spi_has_started;

		if(!expect_started || spi_has_started)
		{
		if(spi_busy == wait_value)
			wait_done   = 1;
		}
	}
	while(!wait_done);

		status = SUCCESS;
	}
	return status;
}

/**
 * @brief 	Function to set the SPI clock frequency
 *
 * This API is used to set the SPI clock frequency.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	sck_freq	     Clock frequency to be set
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */

unsigned char set_spi_clock_freq(spix8_ctl_handle_t *handle,
								unsigned int sck_freq)
{
	unsigned char status = FAILURE;
	unsigned int rdat;
	unsigned int sck_rate;
	unsigned int new_rate;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		rdat     = spix8_ctl->SPIX8_REG_CONFIG0;
		sck_rate = ((rdat & SPIX8_CONFIG0_SCK_RATE) >> 8);
		new_rate = ((handle->sys_clk_freq + (2 * sck_freq) - 1) / (2 * sck_freq));

		if(sck_freq >= handle->sys_clk_freq)
			new_rate  = 0;

		if(new_rate != sck_rate) {
			/* In case there is ongoing SPI transaction, wait until it is done */
			wait_spi_ctl_busy_status(handle,0,0);
			/* Reprogram new rate */
			rdat = (new_rate << 8) | (~SPIX8_CONFIG0_SCK_RATE & rdat);
			spix8_ctl->SPIX8_REG_CONFIG0  = rdat;
			handle->sck_rate              = new_rate;
		}

		handle->spi_actual_freq = (unsigned int)((new_rate == 0)? handle->sys_clk_freq :
								(handle->sys_clk_freq/new_rate/2));

		status = SUCCESS;
	}

return status;
}

#ifdef _MICRON_X8_FLASH_DEVICE_

/**
 * @brief 	Private/Internal function to write the register data
 *
 * This API is used to write the register data (for Micron SPI flash only).
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	reg_data 	     Register data to be written
 * @param 	reg_addr 	     Register address to be written
 * @param 	pkt_fmt 	     Packet format (supported/generic command)
 * @param 	reg_type 	     Write register type (volatile configuration register,
 * 							 non­volatile configuration register,
 * 							 only-write status register)
 *
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */

unsigned char flash_wr_reg(spix8_ctl_handle_t *handle, unsigned int reg_data, unsigned int reg_addr,
						unsigned int pkt_fmt, unsigned int reg_type)
{
	unsigned char status = SUCCESS;

	unsigned int wdat;
	unsigned int rdat;
	unsigned int cmd_code;
	unsigned int usr_cmd;
	unsigned int adr_byte_swap;
	unsigned int adr_width;
	unsigned int enc_io_width;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);
		adr_byte_swap = (handle->flash_addr_mode | handle->spi_dat_rate)? DAT32B_SWAP_BYTES(reg_addr) :
						DAT24B_SWAP_BYTES((reg_addr & 0x00FFFFFF));

		cmd_code = (reg_type == FLASH_REG_VOLATILE    )? FLASH_CMD_WRVCR  :
				(reg_type == FLASH_REG_NON_VOLATILE)? FLASH_CMD_WRNVCR :
				(reg_type == FLASH_REG_STATUS      )? FLASH_CMD_WRSR   :
														FLASH_CMD_PPMR;

		if(pkt_fmt == SPIX8_GEN_CMD)
		{
			/* Send write enable */
			wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
				PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
				PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
				PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
				PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
			spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

			/* Command Code - Write Enable */
			spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_WREN;

			/* Send register write command */
			SET_REG_FIELD(wdat, 0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
			spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

			/* Command Code */
			spix8_ctl->SPIX8_REG_TX_FIFO = cmd_code;

			/* Send address if volatile/non-volatile registers */
			if(reg_type == FLASH_REG_VOLATILE || reg_type == FLASH_REG_NON_VOLATILE)
			{
				SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
				SET_REG_FIELD(wdat, ((handle->flash_addr_mode |
									handle->spi_dat_rate)? 4 : 3), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
				spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

				/* Address */
				spix8_ctl->SPIX8_REG_TX_FIFO = adr_byte_swap;
			}

			/* Send write data */
			SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
			SET_REG_FIELD(wdat, ((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
			spix8_ctl->SPIX8_REG_TX_FIFO    = wdat;

		} /* SPIX8_GEN_CMD */

		else /* SPIX8_SUP_CMD */
		{
			usr_cmd = 0x1F & (((reg_type ==  FLASH_REG_NON_VOLATILE)? FLASH_CMDPATTERN_3 :
											FLASH_CMDPATTERN_2) | USRCMD_PKT_HDR_SETTING);
			enc_io_width = encode_spi_io_width(((handle->spi_io_width & 0x3) << 4) |
											((handle->spi_io_width & 0x3) << 2) |
											((handle->spi_io_width & 0x3)     ));
			/* DW0 */
			wdat = PUT_FIELD_VAL(SPIX8_SUP_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_WITHDAT_WID, PKTHDR_WITHDAT_IDX) |
				PUT_FIELD_VAL(usr_cmd, PKTHDR_USR_CMD_WID, PKTHDR_USR_CMD_IDX) |
				PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_EN2BFCC_WID, PKTHDR_EN2BFCC_IDX) |
				PUT_FIELD_VAL(0, PKTHDR_NUM8SCK_WID, PKTHDR_NUM8SCK_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
			spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

			adr_width = (reg_type == FLASH_REG_VOLATILE ||
						reg_type == FLASH_REG_NON_VOLATILE)? ((handle->flash_addr_mode |
																					handle->spi_dat_rate)? 3 : 2) : 0;
			/* DW1 */
			wdat = PUT_FIELD_VAL(enc_io_width, PKTHDR_CAD_WID_WID, PKTHDR_CAD_WID_IDX) |
				PUT_FIELD_VAL(((handle->spi_dat_rate)? 7 : 0), PKTHDR_XFRRATE_WID, PKTHDR_XFRRATE_IDX) |
				PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_WAIT_DS_WID, PKTHDR_WAIT_DS_IDX) |
				PUT_FIELD_VAL(adr_width, PKTHDR_FADRWID_WID, PKTHDR_FADRWID_IDX) |
				PUT_FIELD_VAL(cmd_code, PKTHDR_CMDCODE_WID, PKTHDR_CMDCODE_IDX);

			spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

			/* DW2 */
			if(reg_type == FLASH_REG_VOLATILE || reg_type == FLASH_REG_NON_VOLATILE)
			{
				/* Address */
				spix8_ctl->SPIX8_REG_TX_FIFO = adr_byte_swap;
			}
		}

		/* Data */
		spix8_ctl->SPIX8_REG_TX_FIFO = GET8B_AND_CONCAT4X(reg_data);

		/* start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		status=SUCCESS;
		if(pkt_fmt == SPIX8_GEN_CMD &&
		reg_type ==  FLASH_REG_NON_VOLATILE)
		{
			do {
				status &= gencmd_flash_rdsr(handle,(unsigned int *)(&rdat));
			} while(rdat & 1);
		}

	}

	return status;
}

#endif

#ifdef _MICRON_X4_FLASH_DEVICE_
/**
 * @brief 	Function to read the register flag status
 *
 * This API is used to read the register flag status (for Micron SPI flash only).
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	rdat	         Pointer to store the flag status value
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_rdfsr(spix8_ctl_handle_t *handle, unsigned int *rdat)
{
	uint32_t status = SUCCESS;
	uint32_t wdat;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send read status flag */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1) , PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - read flag status */
		spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_RDFSR;

		/* Get data */
		SET_REG_FIELD(wdat, SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX);
		SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
		SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
		/* wait until DS asserts before reading in DTR */
		SET_REG_FIELD(wdat, handle->spi_dat_rate, PKTHDR_USEDSTB_WID, PKTHDR_USEDSTB_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* wait to complete */
		wait_spi_ctl_busy_status(handle, 0, 1);

		/* read data from Rx FIFO */
		status &= spix8_rxfifo_rd(handle, rdat, 1);
	}

	return status;
}
#endif


/**
 * @brief 	Function to read the SPI flash device ID
 *
 * This API is used to read the SPI flash device ID.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	rdat	         Pointer to store the ID value
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_rdid(spix8_ctl_handle_t *handle, unsigned int *rdat)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;
	unsigned int num_dummy;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send read ID command */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1) , PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - read flag status */
		spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_RDID;

		num_dummy = 0;

#ifndef _MICRON_X4_FLASH_DEVICE_
		if(handle->spi_io_width == SPIX8_IO_X1)
		{
			/* Send read ID dummy bytes */
			spix8_ctl->SPIX8_REG_TX_FIFO = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
										PUT_FIELD_VAL(SPIX8_WR_CMD , PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
										PUT_FIELD_VAL(1, PKTHDR_DUMMYDT_WID, PKTHDR_DUMMYDT_IDX) |
										PUT_FIELD_VAL(3, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
		}
		else
			num_dummy = 6;

#endif /*_WINBOND_X4_FLASH_DEVICE_*/

		/* Get data */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			/* Wait until DS asserts before reading in DTR */
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_USEDSTB_WID, PKTHDR_USEDSTB_IDX) |
			PUT_FIELD_VAL(num_dummy, PKTHDR_NUM1SCK_WID, PKTHDR_NUM1SCK_IDX) |
			/* 20 bytes ID */
			PUT_FIELD_VAL(FLASH_NUM_RDID_BYTES, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle, 0, 1);

		/* Read data from Rx FIFO */
		status &= spix8_rxfifo_rd(handle,rdat,FLASH_NUM_RDID_DWORDS);
	}

	return status;
}

/**
 * @brief 	Function to write data into Winbond register
 *
 * This API is used to write data into Winbond register-1, -2, or -3
 * (hexadecimal in datasheet of 0x1, 0x31, or 0x1
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	reg_data	     Register data to be written
 * @param 	sr_type	         Register type (register 1, 2, or 3)
 * @param 	reg_type	     Flash register type (volatile configuration register,
 * 							 non­volatile configuration register,
 * 							 only-write status register)
 *
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_wrsr123(spix8_ctl_handle_t *handle,
								unsigned int reg_data, unsigned int sr_type,
								unsigned int reg_type)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;
	unsigned int rdat;
	unsigned int cmd_code;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

#ifndef _MICRON_X4_FLASH_DEVICE_
		cmd_code = (sr_type == 2)? FLASH_CMD_WRSR2  :
				   (sr_type == 3)? FLASH_CMD_WRSR3  :
								   FLASH_CMD_WRSR;
#else
		cmd_code = 0xB1B1B1B1;
#endif

		/* Send write enable */
		wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
				PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
				PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - Write Enable */
#ifndef _WINBOND_X4_FLASH_DEVICE_
		/* Macronix and Micron */
		spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_WREN;
#else
		/* Winbond */
		spix8_ctl->SPIX8_REG_TX_FIFO = (reg_type == FLASH_REG_VOLATILE)?
										FLASH_CMD_WREN_VSR : FLASH_CMD_WREN;
#endif

		/* Send register write status command and data */
		SET_REG_FIELD(wdat, 2, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code + write data */
		spix8_ctl->SPIX8_REG_TX_FIFO = (cmd_code & 0x000000FF) |
									((reg_data << 8) & 0x0000FF00);

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		status = SUCCESS;

		if(reg_type ==  FLASH_REG_NON_VOLATILE)
		{
			do {
				status &= gencmd_flash_rdsr(handle,(unsigned int *)(&rdat));
			}
			while(rdat & 1);
		}
	}
	return status;
}

/**
 * @brief 	Function to read data from Winbond register
 *
 * This API is used to read data from Winbond register-1, -2, or -3
 * (hexadecimal in datasheet of 0x1, 0x31, or 0x11).
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	reg_data	     Register data to be written
 * @param 	sr_type	         Register type (register 1, 2, or 3)
 *
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_rdsr123(spix8_ctl_handle_t *handle, unsigned int *rdat,
								   unsigned int sr_type)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send read status */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			   PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			   PUT_FIELD_VAL(0, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			   PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - read status */
#ifndef _MICRON_X4_FLASH_DEVICE_
		/* Macronix and Winbond */
		spix8_ctl->SPIX8_REG_TX_FIFO = (sr_type == 2)? FLASH_CMD_RDSR2 :
									   (sr_type == 3)? FLASH_CMD_RDSR3 :
													   FLASH_CMD_RDSR;
#else
		/* Micron */
		spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_RDNVCR;
#endif

		/* Get data */
		SET_REG_FIELD(wdat, SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX);
		SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
		SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		/* Read data from Rx FIFO */
		status &= spix8_rxfifo_rd(handle,rdat,1);
	}

	return status;
}

/**
 * @brief 	Function to set the SPI flash address mode.
 *
 * This API is used to set the SPI flash address mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	adr_mode	     Address mode to be set (24 or 32 bits)
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_set_4byte_mode(spix8_ctl_handle_t *handle, unsigned int adr_mode)
{
	unsigned char status=SUCCESS;
	unsigned int wdat;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send write enable */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			   PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			   PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			   PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1) ,
							PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - enter 4byte address / exit 4 byte address */
		spix8_ctl->SPIX8_REG_TX_FIFO = (adr_mode == FLASH_ADDR_MODE_32B)?
										FLASH_CMD_EN4BYTE : FLASH_CMD_EX4BYTE;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		handle->flash_addr_mode = adr_mode;
	}

	return status;
}

/**
 * @brief 	Function to enter quad mode.
 *
 * This API is used to enter quad mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	en_quad	         Enable quad mode or disable quad mode (fall back into x1 mode)
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_set_quad_mode(spix8_ctl_handle_t *handle,
										 unsigned int en_quad)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;
	unsigned int rdat;
	unsigned int en_io_change;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO) {
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		en_io_change = 0;

		if(handle->flash_quad_en == FLASH_QUADSPI_ENABLE) {
			en_io_change = 1;
		}
		else {
			if(en_quad) {
				/* Read status reg2 */
				status &= gencmd_flash_rdsr123(handle,(unsigned int *)(&rdat),2);
				/* Enable QPI */
#ifdef _WINBOND_X4_FLASH_DEVICE_
				rdat = rdat | 0x02; //Winbond
#endif
#ifdef _MACRONIX_X4_FLASH_DEVICE_
				rdat = rdat | 0x40; //Macronix
#endif
#ifdef _MICRON_X4_FLASH_DEVICE_
				rdat = rdat | 0x08; //Micron
#endif
				/* Write status reg2 */
#ifdef _WINBOND_X4_FLASH_DEVICE_
				status &= gencmd_flash_wrsr123(handle, rdat, 2, FLASH_REG_VOLATILE); //Winbond
#else
				status &= gencmd_flash_wrsr123(handle, rdat, 1, FLASH_REG_VOLATILE); //Macronix
#endif
				handle->flash_quad_en = FLASH_QUADSPI_ENABLE;
				en_io_change = 1;
			}
		}

		if(en_io_change) {
			/* Send write enable */
			wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
				   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
				   PUT_FIELD_VAL(handle->spi_io_width , PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
				   PUT_FIELD_VAL(0, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
				   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
				   PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
				   PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

			spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

			/* Command Code - enter QPI / exit QPI */
			spix8_ctl->SPIX8_REG_TX_FIFO = (en_quad)? FLASH_CMD_ENQPI : FLASH_CMD_EXQPI;

			/* Start the transaction */
			spix8_ctl->SPIX8_REG_START_XFER = 1;

			/* Wait to complete */
			wait_spi_ctl_busy_status(handle,0,1);

			handle->spi_io_width = (en_quad)? SPIX8_IO_X4 : SPIX8_IO_X1;
		}
	}

	return status;
}

/**
 * @brief 	Function to perform soft reset
 *
 * This API is used to perform soft reset in the SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_soft_reset(spix8_ctl_handle_t *handle)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send reset enable */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			   PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			   PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			   PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1),
							   PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO    = wdat;

		/* Command Code - Reset Enable */
		spix8_ctl->SPIX8_REG_TX_FIFO    = FLASH_CMD_RSTEN;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		/* Send reset memory */
		/* Same header as reset enable */
		spix8_ctl->SPIX8_REG_TX_FIFO    = wdat;

		/* Command Code - Reset Memory */
		spix8_ctl->SPIX8_REG_TX_FIFO    = FLASH_CMD_RSTMEM;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);
	}

	return status;
}

/**
 * @brief 	Function to set read parameters.
 *
 * This API is used to set read parameters.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	dummy_wrap_cfg	 Dummy wrapper configuration of read param in SPI flash
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_set_read_param(spix8_ctl_handle_t *handle, unsigned int dummy_wrap_cfg)
{
	unsigned char status=SUCCESS;
	unsigned int wdat;
	unsigned int saved_io_width;

	if (!handle)
		return FAILURE;

#ifndef _MICRON_X4_FLASH_DEVICE_
	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);
		saved_io_width = handle->spi_io_width;

		if(handle->spi_io_width != SPIX8_IO_X4)
			status &= gencmd_flash_set_quad_mode(handle, FLASH_QUADSPI_ENABLE);

		/* Send reset enable */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			   PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			   PUT_FIELD_VAL(0, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			   PUT_FIELD_VAL(2, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - Set Read Parameters */
		spix8_ctl->SPIX8_REG_TX_FIFO = (FLASH_CMD_SETREADPARAM & 0x000000FF) |
									   ((dummy_wrap_cfg << 8)  & 0x0000FF00);

		/* start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		handle->flash_dummy_cycle = (dummy_wrap_cfg >> 4) & 0x07;
		handle->flash_wrap_cfg    = dummy_wrap_cfg & 0x03;

		if(saved_io_width != SPIX8_IO_X4) {
			status &= gencmd_flash_set_quad_mode(handle, FLASH_EXTSPI_ENABLE);
		}
	}
#endif /*_WINBOND_X4_FLASH_DEVICE_*/

	return status;
}

/**
 * @brief 	Function to perform 4-kb erase.
 *
 * This API is used to perform 4-kb erase in QSPI mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	start_addr	     Start address of the SPI flash to be erased
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_quadspi_4kb_erase(spix8_ctl_handle_t *handle, unsigned int start_addr)
{
	unsigned char status = SUCCESS;
	op_param_t op_param;

	if (!handle)
		return FAILURE;

	gencmd_flash_set_quad_mode(handle, FLASH_QUADSPI_ENABLE);
#ifdef _MICRON_X4_FLASH_DEVICE_
	op_param = (op_param_t){FLASH_CMD_SSE, 0, 0, 0, 0, 0, 0, 0};
	set_op_param(&op_param);
#else
	gencmd_flash_set_4byte_mode(handle,FLASH_ADDR_MODE_32B);
	op_param = (op_param_t){FLASH_CMD_SSE, 0, 0, 0, 0, 0, 0, 0};
	set_op_param(&op_param);
#endif

	status &= flash_erase(handle, start_addr, SPIX8_GEN_CMD, FLASH_ERASE_4KB);

	return status;
}

/**
 * @brief 	Function to perform page program.
 *
 * This API is used to perform page program in SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to be programed
 * @param 	*dat_buf	     Data buffer pointer to be programed into SPI flash
 * @param 	start_addr	     Start address of the SPI flash to be programmed
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_quadspi_page_program(spix8_ctl_handle_t *handle, unsigned int num_bytes, unsigned int *dat_buf, unsigned int start_addr)
{
	unsigned char status = SUCCESS;

	if (!handle)
		return FAILURE;

	gencmd_flash_set_quad_mode(handle, FLASH_QUADSPI_ENABLE);
#ifndef _MICRON_X4_FLASH_DEVICE_
	gencmd_flash_set_4byte_mode(handle,FLASH_ADDR_MODE_32B);
#endif
	op_param_t params = {FLASH_CMD_PP, SPIX8_IO_X4, SPIX8_IO_X4, SPIX8_IO_X4, 0, 0, 0, 0};
	set_op_param(&params);
	status &= flash_program(handle, num_bytes, dat_buf, start_addr, SPIX8_GEN_CMD);

return status;
}

/**
 * @brief 	Private/Internal function to write the data payload into the Tx FIFO.
 *
 * This API is used to write the data payload into the Tx FIFO.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	*wdat	         Data pointer to be written
 * @param 	num_dat	         Number of data bytes to be written
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char spix8_txfifo_wr(spix8_ctl_handle_t *handle, unsigned int *wdat,
							  unsigned int num_dat)
{
	unsigned char status = FAILURE;
	unsigned int cnt;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(handle->base_addr);

		for(cnt = 0; cnt<num_dat; cnt++)
		{
			spix8_ctl->SPIX8_REG_TX_FIFO = wdat[cnt];
		}

		status = SUCCESS;
	}

	return status;
}

/**
 * @brief 	Private/Internal function to read the data payload from the Rx FIFO.
 *
 * This API is used to read the data payload from the Rx FIFO.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	*rdat	         Data pointer to store data from Rx FIFO
 * @param 	num_dat	         Number of data bytes to be read
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char spix8_rxfifo_rd(spix8_ctl_handle_t *handle, unsigned int *rdat, unsigned int num_dat)
{
	unsigned char status = FAILURE;
	unsigned int cnt;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(handle->base_addr);

		for(cnt = 0; cnt < num_dat; cnt++)
		{
			rdat[cnt] = spix8_ctl->SPIX8_REG_RX_FIFO;
		}

		status = SUCCESS;
	}

	return status;
}

/**
 * @brief 	Function to read the configuration data register.
 *
 * This API is used to read the configuration data register from SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	prog_type	     Program type (for example, fast program and extended fast program)
 * @param 	read_type	     Read type (for example, fast read and octal io fast read)
 * @param 	xip	         	 Option to enable XiP feature
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char config_supported_flash_cmd(spix8_ctl_handle_t *handle,
										 unsigned int prog_type,
										 unsigned int read_type,
										 unsigned int xip)
{
	unsigned char status = SUCCESS;
	unsigned int rdat;
	unsigned int prog_cmd_code;
	unsigned int read_cmd_code;
	unsigned int wren_cmd_code;
	unsigned int rdsr_cmd_code;
	unsigned int rdfsr_cmd_code;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Write enable command */
		wren_cmd_code = FLASH_CMD_WREN;
		spix8_ctl->SPIX8_REG_SUPCMD_CODE0 = FLASH_CMD_WREN;

#ifndef _MICRON_X4_FLASH_DEVICE_
	/* {read flag status, read status} command */
	rdsr_cmd_code   = FLASH_CMD_RDSR;
	rdfsr_cmd_code  = FLASH_CMD_RDSR;
	spix8_ctl->SPIX8_REG_SUPCMD_CODE1 = (FLASH_CMD_RDSR & 0x0000FFFF) |
										(FLASH_CMD_RDSR & 0xFFFF0000);

	prog_cmd_code = (prog_type == FLASH_QUAD_FAST_PROG    )? FLASH_CMD_PP :
					(prog_type == FLASH_EXT_QUAD_FAST_PROG)? ((handle->flash_addr_mode)? FLASH_CMD_4IPP4BYTE : FLASH_CMD_4IPP) :
															((handle->flash_addr_mode)? FLASH_CMD_PP4BYTE   : FLASH_CMD_PP  ) ;

	if(xip)
	{
	read_cmd_code = (handle->spi_io_width == SPIX8_IO_X4)? FLASH_CMD_4IOFR :
					(read_type == FLASH_FAST_READ_2IO   )? ((handle->flash_addr_mode)? FLASH_CMD_2IOFR4BYTE : FLASH_CMD_2IOFR) :
					(read_type == FLASH_FAST_READ_4IO   )? ((handle->flash_addr_mode)? FLASH_CMD_4IOFR4BYTE : FLASH_CMD_4IOFR) :
					(read_type == FLASH_FAST_READ_4IODTR)? FLASH_CMD_4IOFR_DTR :
															FLASH_FAST_READ_4IO ;
	}
	else
	{
	read_cmd_code = (read_type == FLASH_FAST_READ       )? ((handle->flash_addr_mode)? ((handle->spi_io_width == SPIX8_IO_X4)? FLASH_CMD_FAST_READ :
																																FLASH_CMD_FAST_READ4BYTE) :
																						FLASH_CMD_FAST_READ) :
					(read_type == FLASH_FAST_READ_2DO   )? ((handle->flash_addr_mode)? FLASH_CMD_2OFR4BYTE      : FLASH_CMD_2OFR     ) :
					(read_type == FLASH_FAST_READ_2IO   )? ((handle->flash_addr_mode)? FLASH_CMD_2IOFR4BYTE     : FLASH_CMD_2IOFR    ) :
					(read_type == FLASH_FAST_READ_4DO   )? ((handle->flash_addr_mode)? FLASH_CMD_4OFR4BYTE      : FLASH_CMD_4OFR     ) :
					(read_type == FLASH_FAST_READ_4IO   )? ((handle->flash_addr_mode)? FLASH_CMD_4IOFR4BYTE     : FLASH_CMD_4IOFR    ) :
					(read_type == FLASH_FAST_READ_1IODTR)? FLASH_CMD_FAST_READ_DTR :
					(read_type == FLASH_FAST_READ_2IODTR)? FLASH_CMD_2IOFR_DTR     :
					(read_type == FLASH_FAST_READ_4IODTR)? FLASH_CMD_4IOFR_DTR     :
															((handle->flash_addr_mode)? FLASH_CMD_READ4BYTE      : FLASH_CMD_READ     ) ;
	}
#endif /*_WINBOND_X4_FLASH_DEVICE_*/

		/* {fast read, page program} command */
		spix8_ctl->SPIX8_REG_SUPCMD_CODE2 = (prog_cmd_code & 0x0000FFFF) |
											(read_cmd_code & 0xFFFF0000);

		rdat   = spix8_ctl->SPIX8_REG_SUPCMD_CODE0;
		status = ((rdat & 0x000000FF) != (wren_cmd_code & 0x000000FF))?
										  FAILURE : status;

		rdat   = spix8_ctl->SPIX8_REG_SUPCMD_CODE1;
		status = ((rdat & 0x00FF00FF) != ((rdsr_cmd_code  & 0x000000FF) |
										  (rdfsr_cmd_code & 0x00FF0000)))?
										   FAILURE : status;

		rdat   = spix8_ctl->SPIX8_REG_SUPCMD_CODE2;
		status = ((rdat & 0x00FF00FF) != ((prog_cmd_code & 0x000000FF) |
										  (read_cmd_code & 0x00FF0000)))?
										   FAILURE : status;
	}

	return status;
}

/**
 * @brief 	Function to read the configuration data register.
 *
 * This API is used to read the configuration data register from SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	*rdat	         Data pointer to store register data read from SPI flash
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_flash_rdsr(spix8_ctl_handle_t *handle, unsigned int *rdat)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		/* Send read status */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
		PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
		PUT_FIELD_VAL(handle->spi_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
		PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
		PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
		PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
		PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID,
				        PKTHDR_XFERLEN_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code - read status */
		spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_RDSR;

		/* Get data */
		SET_REG_FIELD(wdat, SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX);
		SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
		SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
		SET_REG_FIELD(wdat, handle->spi_dat_rate , PKTHDR_USEDSTB_WID, PKTHDR_USEDSTB_IDX);

		/* Wait until DS asserts before reading in DTR */
		spix8_ctl->SPIX8_REG_TX_FIFO    = wdat;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		/* Read data from Rx FIFO */
		status &= spix8_rxfifo_rd(handle,rdat,1);
	}

	return status;
}

/**
 * @brief 	Private/Internal function to perform the erase action.
 *
 * This API is used to perform the erase action in SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	reg_addr	     Start address to perform erase
 * @param 	pkt_fmt	         Packet format (for example, supported/generic command)
 * @param 	erase_type	     Erase type (for example, chip/4-kb/32-kb erase)
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char flash_erase(spix8_ctl_handle_t *handle, unsigned int reg_addr,
					      unsigned int pkt_fmt, unsigned int erase_type)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;
	unsigned int rdat;
	unsigned int adr_byte_swap;
	unsigned int cnt = 0;

	if (!handle || handle->base_addr == ZERO)
		return FAILURE;

	spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(handle->base_addr);

	if (handle->flash_addr_mode | handle->spi_dat_rate)
		adr_byte_swap = DAT32B_SWAP_BYTES(reg_addr);
	else
		adr_byte_swap = DAT24B_SWAP_BYTES((reg_addr & 0x00FFFFFF));


	/* Send write enable */
	wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(handle->spi_io_width,PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

	/* Command Code - Write Enable */
	spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_WREN;

	/* Send Erase command */
	SET_REG_FIELD(wdat, ((erase_type == FLASH_ERASE_CHIP)? 1 : 0),
					PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

	/* Command Code */
	spix8_ctl->SPIX8_REG_TX_FIFO = octal_spi_op_st.command;

	/* Send address if not Chip Erase */
	if(erase_type != FLASH_ERASE_CHIP)
	{
		SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
		SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
		SET_REG_FIELD(wdat, ((handle->flash_addr_mode | handle->spi_dat_rate)? 4 : 3),
						    PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO  = wdat;

		/* Address */
		spix8_ctl->SPIX8_REG_TX_FIFO  = adr_byte_swap;
	}


	/* Start the transaction */
	spix8_ctl->SPIX8_REG_START_XFER = 1;

	/* Wait to complete */
	wait_spi_ctl_busy_status(handle,0,1);

	status = SUCCESS;
	if(pkt_fmt == SPIX8_GEN_CMD)
	{
		do
		{
			status &= gencmd_flash_rdsr(handle,(unsigned int *)(&rdat));
			cnt++;
		}
		while(rdat & 1);
	}

	return status;
}

/**
 * @brief 	Private/Internal function to perform the read action.
 *
 * This API is used to perform the read action in SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to read
 * @param 	*dat_buf	     Pointer to store the read back data
 * @param 	start_addr	     Start address of data to read
 * @param 	pkt_fmt	         Packet format (for example, supported/generic command)
 * @param 	read_type	     Read type (for example, fast read and octal io fast read)
 * @param 	use_data_stb	 Data strobe enable
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char flash_read(spix8_ctl_handle_t *handle, unsigned int num_bytes, unsigned int *dat_buf,
					     unsigned int start_addr, unsigned int pkt_fmt, unsigned int use_data_stb)
{
	unsigned char status = SUCCESS;
	unsigned int wdat = 0;
	unsigned int adr_byte_swap = 0;
	unsigned int byte_len = 0;
	unsigned int dword_len = 0;
	unsigned int adr_4bytes = 0;

	if (!handle || handle->base_addr == ZERO)
		return FAILURE;

	spix8_ctl_reg_t *spix8_ctl = (spix8_ctl_reg_t *)(handle->base_addr);

	if (handle->flash_addr_mode == FLASH_ADDR_MODE_32B)
		adr_4bytes = 1;

	byte_len  = (octal_spi_op_st.data_io_rate)? (num_bytes & 0x1FF) + ((num_bytes & 0x1) << 1): num_bytes;
	dword_len = (byte_len >> 2) + ((byte_len & 0x3)?  1 : 0);

	/* In Octal DDR, address must be even */
	adr_byte_swap = (octal_spi_op_st.adr_io_rate)? start_addr & 0xFFFFFFFE : start_addr;
	adr_byte_swap = (adr_4bytes)? DAT32B_SWAP_BYTES(start_addr) :
					DAT24B_SWAP_BYTES((start_addr & 0x00FFFFFF));


	/* Send flash read command */
	wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(octal_spi_op_st.cmd_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(octal_spi_op_st.cmd_io_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;
	/* Command Code */
	spix8_ctl->SPIX8_REG_TX_FIFO = octal_spi_op_st.command;

	/* Send address */
	SET_REG_FIELD(wdat, octal_spi_op_st.adr_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX);
	SET_REG_FIELD(wdat, octal_spi_op_st.adr_io_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX);
	SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
	SET_REG_FIELD(wdat, ((handle->flash_addr_mode | octal_spi_op_st.adr_io_rate )? 4 : 3),
						  PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO  = wdat;

	/* Address */
	spix8_ctl->SPIX8_REG_TX_FIFO  = adr_byte_swap;

	/* Get data */
	if((use_data_stb == 0) && ((octal_spi_op_st.dummy_cycle >> 3) > 0))
	{
		/* need to provide the required dummy cycle */
		spix8_ctl->SPIX8_REG_TX_FIFO = \
		PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
		PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
		PUT_FIELD_VAL(1, PKTHDR_DUMMYDT_WID, PKTHDR_DUMMYDT_IDX) |
		PUT_FIELD_VAL((octal_spi_op_st.dummy_cycle >> 3), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
	}

	/* Get register data */
	wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(octal_spi_op_st.data_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(octal_spi_op_st.data_io_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((use_data_stb)? 0 :
							(octal_spi_op_st.dummy_cycle & 0x7)), PKTHDR_NUM1SCK_WID, PKTHDR_NUM1SCK_IDX) |
			PUT_FIELD_VAL(byte_len, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO    = wdat;

	/* start the transaction */
	spix8_ctl->SPIX8_REG_START_XFER = 1;

	/* wait to complete */
	wait_spi_ctl_busy_status(handle,0,1);

	status = SUCCESS;
	status &= spix8_rxfifo_rd(handle, dat_buf, dword_len);

	return status;
}

/**
 * @brief 	Private/Internal function to perform the program action.
 *
 * This API is used to perform the program action in SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to program
 * @param 	*dat_buf	     Pointer to store the data to be programmed
 * @param 	start_addr	     Start address of data to programmed
 * @param 	pkt_fmt	         Packet format (for example, supported/generic command)
 * @param 	prog_type	     Program type (for example, page program and quad fast program)
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char flash_program(spix8_ctl_handle_t *handle, unsigned int num_bytes, unsigned int *dat_buf,
					        unsigned int start_addr, unsigned int pkt_fmt)
{
	unsigned char status = FAILURE;
	unsigned int wdat;
	unsigned int rdat;

	unsigned int adr_byte_swap;

	unsigned int byte_len;
	unsigned int dword_len;
	unsigned int cnt = 0;

	if (!handle || handle->base_addr == ZERO)
		return FAILURE;


	spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

	byte_len  = (handle->spi_dat_rate)? (num_bytes & 0x1FF) +
									((num_bytes & 0x1) << 1) : num_bytes;
	dword_len = (byte_len >> 2) + ((byte_len & 0x3)?  1 : 0);

	/* In Octal DDR, address must be even */
	adr_byte_swap = (handle->spi_dat_rate)? start_addr & 0xFFFFFFFE : start_addr;
	adr_byte_swap = (handle->flash_addr_mode | handle->spi_dat_rate)?
					DAT32B_SWAP_BYTES(start_addr) :
					DAT24B_SWAP_BYTES((start_addr & 0x00FFFFFF));

	/* Send write enable */
	wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			PUT_FIELD_VAL(octal_spi_op_st.cmd_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			PUT_FIELD_VAL(handle->spi_dat_rate, PKTHDR_DATRATE_WID, PKTHDR_DATRATE_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			PUT_FIELD_VAL(((handle->spi_dat_rate)? 2 : 1), PKTHDR_XFERLEN_WID,
							PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

	/* Command Code - Write Enable */
	spix8_ctl->SPIX8_REG_TX_FIFO = FLASH_CMD_WREN;

	/* Send Program command */
	SET_REG_FIELD(wdat, octal_spi_op_st.cmd_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX);
	SET_REG_FIELD(wdat, 0,PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

	/* Command Code */
	spix8_ctl->SPIX8_REG_TX_FIFO = octal_spi_op_st.command;

	/* Send address */
	SET_REG_FIELD(wdat, octal_spi_op_st.adr_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX);
	SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
	SET_REG_FIELD(wdat, ((handle->flash_addr_mode |
						handle->spi_dat_rate)? 4 : 3), PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

	spix8_ctl->SPIX8_REG_TX_FIFO  = wdat;

	/* Address */
	spix8_ctl->SPIX8_REG_TX_FIFO  = adr_byte_swap;

	/* Send data */
	SET_REG_FIELD(wdat, octal_spi_op_st.data_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX);
	SET_REG_FIELD(wdat, 1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX);
	SET_REG_FIELD(wdat, byte_len, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
	spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

	/* Early start of transaction */
	spix8_ctl->SPIX8_REG_START_XFER = 1;

	/* Write data payload to Tx FIFO */
	spix8_txfifo_wr(handle, dat_buf, dword_len);

	/* Start the transaction */
	spix8_ctl->SPIX8_REG_START_XFER = 1;

	/* Wait to complete */
	wait_spi_ctl_busy_status(handle,0,1);

	status = SUCCESS;
	if(pkt_fmt == SPIX8_GEN_CMD)
	{
		do {
			status &= gencmd_flash_rdsr(handle,(unsigned int *)(&rdat));
			cnt++;
		}
		while(rdat & 1);

#ifdef _MICRON_X4_FLASH_DEVICE_
		status &= gencmd_flash_rdfsr(handle,(unsigned int *)(&rdat));
		status = (GET_FIELD_VAL(rdat,FLASH_FLG_PROGM_FAIL_IDX,1))? FAILURE : status;
#endif /*_MICRON_X4_FLASH_DEVICE_*/
	}

	return status;
}

/**
 * @brief 	Function to set the Supported Command Configuration Registers.
 *
 * This API is used to set the Supported Command Configuration Registers (offset 0x18).
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	prog_type	     Program type (for example, fast program and extended fast program)
 * @param 	read_type	     Read type (for example, fast read and octal io fast read)
 * @param 	wr1_rd0	      	 Write or read option to be configure
 * @param 	xip	        	 Option to enable XiP feature
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char set_quad_flash_command_config(spix8_ctl_handle_t *handle, unsigned int prog_type,
									        unsigned int read_type, unsigned int wr1_rd0, unsigned char xip)
{
	unsigned char status = FAILURE;
	unsigned int wdat=0;
	unsigned int enc_io_width;
	unsigned int data_rate;
	unsigned int dummy_cycle;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
#ifndef _MICRON_X4_FLASH_DEVICE_
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);

		if(handle->spi_io_width == SPIX8_IO_X4)
		{
			enc_io_width  = encode_spi_io_width(SPIX8_IO_X4_X4_X4);
		}
		else if(wr1_rd0)
		{
			switch (prog_type)
			{
				case FLASH_EXT_QUAD_FAST_PROG  : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X1_X4); break;
				default                        : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X1_X1); break;
			}
		}
		else
		{
			switch (read_type)
			{
				case FLASH_FAST_READ_2DO : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X1_X2); break;
				case FLASH_FAST_READ_2IO : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X2_X2); break;
				case FLASH_FAST_READ_4DO : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X1_X4); break;
				case FLASH_FAST_READ_4IO : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X4_X4); break;
				default                  : enc_io_width = encode_spi_io_width(SPIX8_IO_X1_X1_X1); break;
			}
		}
		data_rate   = 0x0;

		dummy_cycle = octal_spi_op_st.dummy_cycle;

		if(xip && (dummy_cycle > 0))
		{
			/* need to subtract the cycles used on xip address pad */
			dummy_cycle = (read_type == FLASH_FAST_READ_2IO)? ((dummy_cycle > 4)? (dummy_cycle - 4) : 0) :
							(read_type == FLASH_FAST_READ_4IO)? ((dummy_cycle > 2)? (dummy_cycle - 2) : 0) :
																(dummy_cycle - 1);
		}

		wdat =  PUT_FIELD_VAL(enc_io_width, SUPCMD_CFG_LANE_WIDTH_WID,
							SUPCMD_CFG_LANE_WIDTH_IDX) |
				PUT_FIELD_VAL(data_rate, SUPCMD_CFG_XFER_RATE_WID,
								SUPCMD_CFG_XFER_RATE_IDX) |
				PUT_FIELD_VAL(dummy_cycle, SUPCMD_CFG_FASTRD_DUMMY_WID,
								SUPCMD_CFG_FASTRD_DUMMY_IDX) |
				PUT_FIELD_VAL(handle->flash_addr_mode,  SUPCMD_CFG_ADDR_MODE_WID,
								SUPCMD_CFG_ADDR_MODE_IDX);

	spix8_ctl->SPIX8_REG_SUPCMD_CFG = wdat;

		status = SUCCESS;
#endif /*_WINBOND_X4_FLASH_DEVICE_*/
	}

	return status;
}

/**
 * @brief 	Function to perform the QSPI fast read action.
 *
 * This API is used to perform the QSPI fast read action in SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to read
 * @param 	*dat_buf	     Pointer to store the read back data
 * @param 	start_addr	     Start address of data to read
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_quadspi_fast_read(spix8_ctl_handle_t *handle,
									   unsigned int num_bytes,
									   unsigned int *dat_buf,
									   unsigned int start_addr)
{
	unsigned char status = SUCCESS;

	if (!handle)
		return FAILURE;

	op_param_t op_param;

	gencmd_flash_set_quad_mode(handle, FLASH_QUADSPI_ENABLE);

#ifndef _MICRON_X4_FLASH_DEVICE_
	gencmd_flash_set_4byte_mode(handle,FLASH_ADDR_MODE_32B);
#endif

#ifdef _WINBOND_X4_FLASH_DEVICE_
	op_param = (op_param_t){FLASH_CMD_FAST_READ, SPIX8_IO_X4, SPIX8_IO_X4, SPIX8_IO_X4, 0, 0, 0, 2};
	set_op_param(&op_param);
	status &= flash_read(handle, num_bytes, dat_buf, start_addr,
						SPIX8_GEN_CMD, 0/*use_ds*/);
#endif

#ifdef _MACRONIX_X4_FLASH_DEVICE_
	op_param = (op_param_t){FLASH_CMD_4IOFR4BYTE, SPIX8_IO_X1, SPIX8_IO_X4, SPIX8_IO_X4, 0, 0, 0, 6};
	set_op_param(&op_param);
	status &= flash_read(handle, num_bytes, dat_buf, start_addr,
						SPIX8_GEN_CMD, 0/*use_ds*/);
#endif

#ifdef _MICRON_X4_FLASH_DEVICE_
	op_param = (op_param_t){FLASH_CMD_4IOFR4BYTE, SPIX8_IO_X4, SPIX8_IO_X4, SPIX8_IO_X4, 0, 0, 0, 10};
	set_op_param(&op_param);
	status &= flash_read(handle, num_bytes, dat_buf, start_addr, SPIX8_GEN_CMD, 0/*use_ds*/);
#endif

	return status;
}

/**
 * @brief 	Function to activate the XiP.
 *
 * This API is used to activate the XiP feature of the SPI flash.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	read_type	     Read type (for example, fast read and octal io fast read)
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char quad_xip_activate(spix8_ctl_handle_t *handle, unsigned int read_type)
{
	unsigned char status = SUCCESS;
	unsigned int wdat;
	unsigned int dummy;

	unsigned int cmd_code;
	unsigned int adr_width;
	unsigned int dummy_cycle;

	unsigned int cmd_io_width;
	unsigned int adr_io_width;
	unsigned int dat_io_width;

	if (!handle)
		return FAILURE;

	if(handle->base_addr != ZERO)
	{
#ifndef _MICRON_X4_FLASH_DEVICE_
		spix8_ctl_reg_t *spix8_ctl=(spix8_ctl_reg_t *)(handle->base_addr);
		cmd_code = FLASH_CMD_4IOFR;

		if(handle->spi_io_width == SPIX8_IO_X4) {
			cmd_io_width = SPIX8_IO_X4;
			adr_io_width = SPIX8_IO_X4;
			dat_io_width = SPIX8_IO_X4;
		}
		else {
			cmd_io_width = SPIX8_IO_X1;
		}
		if(read_type == FLASH_FAST_READ_2IO) {
			adr_io_width = SPIX8_IO_X2;
			dat_io_width = SPIX8_IO_X2;
			if (handle->flash_addr_mode)
				cmd_code = FLASH_CMD_2IOFR4BYTE;
			else
				cmd_code = FLASH_CMD_2IOFR;

		}
		else if(read_type == FLASH_FAST_READ_4IO) {
			adr_io_width = SPIX8_IO_X4;
			dat_io_width = SPIX8_IO_X4;
		}
		else {
			if (handle->flash_addr_mode)
				cmd_code = FLASH_CMD_4IOFR4BYTE;
		}

		/* need to subtract the cycles used on xip address pad */
		dummy_cycle = (read_type == FLASH_FAST_READ_2IO   )? 4-4 :
					  ((handle->flash_dummy_cycle == 7)? ((handle->spi_io_width == SPIX8_IO_X4)? 16-2 : 16-2) :
					  (handle->flash_dummy_cycle == 6)? ((handle->spi_io_width == SPIX8_IO_X4)? 14-2 : 14-2) :
					  (handle->flash_dummy_cycle == 5)? ((handle->spi_io_width == SPIX8_IO_X4)? 12-2 : 12-2) :
					  (handle->flash_dummy_cycle == 4)? ((handle->spi_io_width == SPIX8_IO_X4)? 10-2 : 10-2) :
					  (handle->flash_dummy_cycle == 3)? ((handle->spi_io_width == SPIX8_IO_X4)? 8 -2 : 8 -2) :
					  (handle->flash_dummy_cycle == 2)? ((handle->spi_io_width == SPIX8_IO_X4)? 6 -2 : 6 -2) :
					  (handle->flash_dummy_cycle == 1)? ((handle->spi_io_width == SPIX8_IO_X4)? 4 -2 : 6 -2) :
					  ((handle->spi_io_width == SPIX8_IO_X4)? 2 -2 : 6 -2) );

		/* Send flash read command */
		wdat = PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
			   PUT_FIELD_VAL(SPIX8_WR_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
			   PUT_FIELD_VAL(cmd_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
			   PUT_FIELD_VAL(0, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
			   PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Command Code */
		spix8_ctl->SPIX8_REG_TX_FIFO = cmd_code;

		/* Send address */
		adr_width = (handle->flash_addr_mode)? 5 : 4;
		SET_REG_FIELD(wdat, adr_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX);
		SET_REG_FIELD(wdat, 0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX);
		SET_REG_FIELD(wdat, adr_width, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);
		spix8_ctl->SPIX8_REG_TX_FIFO  = wdat;

		/* Address */
		if(handle->flash_addr_mode) {
			spix8_ctl->SPIX8_REG_TX_FIFO = 0;
			spix8_ctl->SPIX8_REG_TX_FIFO = 0xA5;
		}
		else
			spix8_ctl->SPIX8_REG_TX_FIFO = 0xA5000000;

		/* Dummy cycle */
		if(((dummy_cycle >> 3) > 0))
		{
			/* need to provide the required dummy cycle */
			spix8_ctl->SPIX8_REG_TX_FIFO = PUT_FIELD_VAL(SPIX8_GEN_CMD,
														 PKTHDR_SUP_FCC_WID,
														 PKTHDR_SUP_FCC_IDX) |
										   PUT_FIELD_VAL(SPIX8_WR_CMD,
														 PKTHDR_CMDTYPE_WID,
														 PKTHDR_CMDTYPE_IDX) |
										   PUT_FIELD_VAL(1, PKTHDR_DUMMYDT_WID,
														 PKTHDR_DUMMYDT_IDX) |
										   PUT_FIELD_VAL((dummy_cycle >> 3) ,
														 PKTHDR_XFERLEN_WID,
														 PKTHDR_XFERLEN_IDX);
		}

		/* Get data */
		wdat =  PUT_FIELD_VAL(SPIX8_GEN_CMD, PKTHDR_SUP_FCC_WID, PKTHDR_SUP_FCC_IDX) |
				PUT_FIELD_VAL(SPIX8_RD_CMD, PKTHDR_CMDTYPE_WID, PKTHDR_CMDTYPE_IDX) |
				PUT_FIELD_VAL(dat_io_width, PKTHDR_LANEWID_WID, PKTHDR_LANEWID_IDX) |
				PUT_FIELD_VAL(0, PKTHDR_FRM_SOP_WID, PKTHDR_FRM_SOP_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_FRM_EOP_WID, PKTHDR_FRM_EOP_IDX) |
				PUT_FIELD_VAL((dummy_cycle & 0x7) , PKTHDR_NUM1SCK_WID, PKTHDR_NUM1SCK_IDX) |
				PUT_FIELD_VAL(1, PKTHDR_XFERLEN_WID, PKTHDR_XFERLEN_IDX);

		spix8_ctl->SPIX8_REG_TX_FIFO = wdat;

		/* Start the transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 1;

		/* Wait to complete */
		wait_spi_ctl_busy_status(handle,0,1);

		/* Pop the dummy data */
		dummy = spix8_ctl->SPIX8_REG_RX_FIFO;
		dummy = dummy + 1;

		/* Start the XiP transaction */
		spix8_ctl->SPIX8_REG_START_XFER = 3;

#endif /*_WINBOND_X4_FLASH_DEVICE_*/
		status = SUCCESS;
	}

	return status;
}

#ifdef _MICRON_X8_FLASH_DEVICE_
//Octal SPI functions

/**
 * @brief 	Function to configure flash registers to Octal SPI mode.
 *
 * This API is used to configure flash registers to Octal SPI mode and set spix8_ctl_handle_t
 * struct members to Octal SPI configurations.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	en_octal	     0: Disable Octal SPI mode
 * 							 1: Enable Octal SPI mode
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
uint32_t gencmd_wr_vcr_set_octal_mode(spix8_ctl_handle_t *handle, uint32_t en_octal)
{
	uint32_t status=SUCCESS;

	uint32_t code_io_mode;

	code_io_mode = (en_octal)? FLASH_IO_MODE_OCTSPI : FLASH_IO_MODE_EXTSPI;

	status &= flash_wr_reg(handle, code_io_mode, /*reg_addr=*/0x00, SPIX8_GEN_CMD, FLASH_REG_VOLATILE);

	if(status == SUCCESS)
	{
		handle->spi_io_width = (en_octal)? SPIX8_IO_X8 : SPIX8_IO_X1;
		handle->spi_dat_rate = (en_octal)? SPIX8_DTR   : SPIX8_STR;
	}

	return status;
}

/**
 * @brief 	Function to perform erase operation in Octal SPI mode.
 *
 * This API is used to perform erase operation in Octal SPI mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	erase_type	     Erase type to perform
 * @param 	start_addr	     Start address to perform erase operation
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_octspi_erase(spix8_ctl_handle_t *handle, unsigned char erase_type, unsigned int start_addr)
{
	unsigned char status = FAILURE;

	if (!handle)
		return status;

	if(handle->spi_io_width != SPIX8_IO_X8)
		status &= gencmd_wr_vcr_set_octal_mode(handle,FLASH_OCTSPI_ENABLE);

	status &= flash_erase(handle, start_addr, SPIX8_GEN_CMD, erase_type);

	return status;
}

/**
 * @brief 	Function to perform fast read operation in Octal SPI mode.
 *
 * This API is used to perform fast read operation in Octal SPI mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to be read from
 * @param 	*dat_buf	     Pointer to store the data read from SPI flash
 * @param 	start_addr	     Start address to perform read operation
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_octspi_fast_read(spix8_ctl_handle_t *handle, unsigned int num_bytes, unsigned int *dat_buf, unsigned int start_addr)
{
	unsigned char status = FAILURE;

	if (!handle)
		return status;

	if(handle->spi_io_width != SPIX8_IO_X8)
		status &= gencmd_wr_vcr_set_octal_mode(handle,FLASH_OCTSPI_ENABLE);

	status &= flash_read(handle, num_bytes, dat_buf, start_addr, SPIX8_GEN_CMD, FLASH_FAST_READ, 1/*use_ds*/);

	return status;
}

/**
 * @brief 	Function to perform page program operation in Octal SPI mode.
 *
 * This API is used to perform page program operation in Octal SPI mode.
 *
 * @param 	handle	         Handle of the spix8_ctl_handle_t structure
 * @param 	num_bytes	     Number of data (per 4 bytes) to be written
 * @param 	*dat_buf	     Data pointer to be written into SPI flash
 * @param 	start_addr	     Start address to perform page program operation
 * @return 	                 Returns 'SUCCESS' (0) on success,
 * 					         or 'FAILURE' (1) if input pointer is NULL.
 */
unsigned char gencmd_octspi_page_program(spix8_ctl_handle_t *handle, unsigned int num_bytes, unsigned int *dat_buf, unsigned int start_addr)
{
	unsigned char status = FAILURE;

	if (!handle)
		return status;

	if(handle->spi_io_width != SPIX8_IO_X8)
		status &= gencmd_wr_vcr_set_octal_mode(handle,FLASH_OCTSPI_ENABLE);

	status &= flash_program(handle, num_bytes, dat_buf, start_addr, SPIX8_GEN_CMD, FLASH_PAGE_PROG);

	return status;
}

#endif

