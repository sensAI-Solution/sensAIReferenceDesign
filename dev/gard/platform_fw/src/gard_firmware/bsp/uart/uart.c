/*   ==================================================================

	 >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
	 ------------------------------------------------------------------
	 Copyright (c) 2019-2025 by Lattice Semiconductor Corporation
	 ALL RIGHTS RESERVED
	 ------------------------------------------------------------------

	   IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
	   DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

	   Lattice grants permission to use this code pursuant to the
	   terms of the Lattice Propel License Agreement.

	 DISCLAIMER:

	LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
	WHETHER EXPRESSED, IMPLIED, STATUTORY,
	OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
	COMMUNICATION WITH LICENSEE,
	AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
	MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
	LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
	LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
	SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
	UNINTERRUPTED OR ERROR FREE,
	OR THAT DEFECTS HEREIN WILL BE CORRECTED.
	LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
	ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
	AND RESULTS OBTAINED THEREFROM.
	LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
	DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
	LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
	CORRECTION,
	OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
	SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
	INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
	INCLUDING LOST PROFITS,
	ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
	EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
	LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
	IS SET FORTH ABOVE.
	LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
	ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
	INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
	RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
	FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
	 ------------------------------------------------------------------

	 ================================================================== */
#include "types.h"
#include "uart.h"

/*
 ------------------------------------------------------
 -                                                    -
 - UART Device Register-map                           -
 -                                                    -
 ------------------------------------------------------
 */
struct uart_dev {
	volatile uint32_t rxtx;
	volatile uint32_t ier;
	volatile uint32_t iir;
	volatile uint32_t lcr;
	volatile uint32_t reserved1;
	volatile uint32_t lsr;
	volatile uint32_t reserved2;
	volatile uint32_t reserved3;
	volatile uint32_t dlr_lsb;
	volatile uint32_t dlr_msb;
};

#define UART_BUFFER_SIZE 16

/*
 ***************************************************************
 * UART ISR: Automatically optimized-out (it's a "static") if
 * _UART_NO_INTERRUPTS_ is defined as part of preprocessor
 * settings.  Note this preprocessor setting affects ALL
 * UART instances.
 ***************************************************************
 */

#ifndef _UART_NO_INTERRUPTS_
static void uart_isr(void *ctx)
{
	struct uart_instance     *uart;
	volatile struct uart_dev *dev;
	uint8_t                   iir;
	uint8_t                   ier;

	uart = (struct uart_instance *)ctx;
	dev  = (volatile struct uart_dev *)(uart->base);

	/* interrogate interrupt-cause */
	iir  = dev->iir;
	ier  = dev->ier;

	/* see if the interrupt is due to rx-data */
	switch (iir) {
	case UART_IIR_RXRDY: {
		/*
		 * read lsr to check for errors associated with current word.
		 * reading lsr clears error bits
		 */
		uint8_t lsr                      = dev->lsr;

		/* read the data into the buffer */
		uart->rxBuffer[uart->rxWriteLoc] = dev->rxtx;

		/* check for error(s) with the current word */
		if ((lsr & (UART_LSR_PE_MASK | UART_LSR_FE_MASK)) == 0) {
			/* no error detected, adjust rx buffer pointers */
			uart->rxWriteLoc++;
			if (uart->rxWriteLoc >= uart->rxBufferSize) {
				uart->rxWriteLoc = 0;
			}
			uart->rxDataBytes++;

			/* if buffer's full, disable interrupts */
			if (uart->rxDataBytes == uart->rxBufferSize) {
				uart->ier &= (~UART_IER_RX_INT_MASK);
				dev->ier   = uart->ier;
			}
		}
	} break;

	case UART_IIR_TXRDY: {
		uint32_t count;
		if (uart->fifoenable) {
			/* see if there's stuff to transmit */
			count = (uart->txDataBytes > 16) ? 16 : uart->txDataBytes;
			// count = 16;
		} else {
			count = (uart->txDataBytes == 0) ? 0 : 1;
			// count = 1;
		}
		/* put 16 data words to the TX FIFO of
		 * the UART if data is available
		 */
		while (count != 0) {
			if (uart->txDataBytes == 1) {
				/* disable tx interrupts as this is the last data to send */
				uart->ier &= (~UART_IER_TX_INT_MASK);
				dev->ier   = uart->ier;
			}
			dev->rxtx = uart->txBuffer[uart->txReadLoc];
			uart->txReadLoc++;
			if (uart->txReadLoc >= uart->txBufferSize) {
				uart->txReadLoc = 0;
			}
			--uart->txDataBytes;
			--count;
#if 1
			if (uart->txDataBytes == 0) {
				break;
			}
#endif
		}
	} break;

	default: {
		/*
		 * This will never happen unless someone's reading rx
		 * in parallel.  If using interrupts, isr is the only
		 * code that should be reading rx
		 */
	} break;
	}

	/* all done */
	return;
}
#endif

uint8_t uart_init(struct uart_instance *this_uart,
				  uint32_t              base_addr,
				  uint32_t              sys_clk,
				  uint32_t              baud_rate,
				  uint8_t               stop_bits,
				  uint8_t               data_width)
{
	volatile struct uart_dev *dev;
	if (NULL == this_uart) {
		return 1;
	}
	this_uart->base     = base_addr;
	dev                 = (volatile struct uart_dev *)(this_uart->base);
	dev                 = dev;

	/*initialize the instance data */
	this_uart->base     = base_addr;
	this_uart->sys_clk  = sys_clk;
	this_uart->baudrate = baud_rate;
	this_uart->databits = data_width;
	this_uart->stopbits = stop_bits;

	/* set the data-configuration */
	uart_config(this_uart, 8, 0, 0, 1);

	this_uart->blockingTx = 1;
	this_uart->blockingRx = 1;
#ifndef _UART_NO_INTERRUPTS_
	/* If interrupts are available use interrupt-mode */
	if (this_uart->intrAvail) {
		/* initialize buffer-related parameters */
		this_uart->txDataBytes  = 0;
		this_uart->rxDataBytes  = 0;
		this_uart->txReadLoc    = 0;
		this_uart->txWriteLoc   = 0;
		this_uart->rxReadLoc    = 0;
		this_uart->rxWriteLoc   = 0;
		this_uart->rxBufferSize = UART_BUFFER_SIZE;
		this_uart->txBufferSize = UART_BUFFER_SIZE;
		/*
		 * Don't enable transmit interrupt as the write-function takes care of
		 * doing that
		 */
		this_uart->ier          = UART_IER_RX_INT_MASK;
		dev->ier                = this_uart->ier;

		/* Register interrupt-handler for this uart's interrupt */
		pic_isr_register(this_uart->intrLevel, uart_isr,
						 this_uart);  // uart_isr have two parameter!!!!!
	}
#endif

	/* all done! */
	return 0;
}

/*
 ***************************************************************
 * Retrieves characters from UART in the buffer for count bytes.
 * The routine returns the number of characters read which could be less than
 * the requested count if there are not enough characters available in the UART.
 * Returns the number of characters read from UART.
 ***************************************************************
 */
uint32_t uart_getchars(void *handle, uint8_t *buffer, uint32_t count)
{
	struct uart_instance     *this_uart = (struct uart_instance *)handle;
	volatile struct uart_dev *dev;
	uint32_t                  bytes_read = 0;

	if (NULL == this_uart) {
		return 0;
	}

	dev = (volatile struct uart_dev *)(this_uart->base);

	if ((dev->lsr & UART_LSR_RX_RDY_MASK) == 0 || count == 0) {
		return 0;  // No data available to read
	}

	while (bytes_read < count && (dev->lsr & UART_LSR_RX_RDY_MASK)) {
		buffer[bytes_read] = dev->rxtx;  // Read the character
		bytes_read++;
	}

	return bytes_read;
}

/*
 ***************************************************************
 * Puts characters to UART from the buffer for count bytes.
 * It returns the number of characters sent which could be less than
 * the requested count if there is not enough space in the UART FIFO.
 * The caller should not assume that all characters have reached the peer UART
 * port as the UART FIFO will be drained out by the UART hardware in its own
 * time.
 *  ** This code assumes a 16-byte FIFO in the UART **
 * Returns false if no bytes were sent; true if at least one byte was sent.
 ***************************************************************
 */
uint32_t uart_putchars(void *handle, uint8_t *buffer, uint32_t count)
{
	struct uart_instance     *this_uart = (struct uart_instance *)handle;
	volatile struct uart_dev *dev;
	uint32_t                  bytes_sent = 0;

	if (NULL == this_uart) {
		return 0;
	}

	dev = (volatile struct uart_dev *)(this_uart->base);

	if (((dev->lsr & (UART_LSR_TX_RDY_MASK | UART_LSR_TX_FIFO_EMPTY)) == 0) ||
		count == 0) {
		return 0;
	}

	count = (count > 16) ? 16 : count;  // Limit to 16 bytes

	while (bytes_sent < count) {
		dev->rxtx = *buffer++;  // Send the byte
		bytes_sent++;
	}

	return bytes_sent;
}

/*
 ***************************************************************
 * Changes datawidth, parity-selection and stop-bit selection
 *
 * Argument:
 *
 * uart_instance *ctx: context to uart
 * uint32_t dwidth: data width in bits(5, 6, 7, 8)
 * uint32_t parity_en: 0 => no pareity, 1 => parity enabled
 * uint32_t even_odd (parity): - 1 => even, 0 => odd
 * uint32_t stopbits: stop bits (1,2)
 *
 ***************************************************************
 */
uint8_t uart_config(struct uart_instance *this_uart,
					uint32_t              dwidth,
					uint8_t               parity_en,
					uint8_t               even_odd,
					uint32_t              stopbits)
{
	volatile struct uart_dev *dev;
	uint8_t                   lcr;
	if (NULL == this_uart) {
		return 1;
	}
	dev = (volatile struct uart_dev *)(this_uart->base);

	/* check data-width value */
	if (dwidth > 8) {
		return (UART_ERR_INVALID_ARGUMENT);
	} else if (dwidth < 5) {
		return (UART_ERR_INVALID_ARGUMENT);
	}

	/* check stopbit value */
	if ((stopbits != 1) && (stopbits != 2)) {
		return (UART_ERR_INVALID_ARGUMENT);
	}

	/* update context */
	this_uart->databits = dwidth;
	this_uart->stopbits = stopbits;

	/* configure UART */
	switch (dwidth) {
	case 5: {
		lcr = (stopbits == 2) ? 0x4 : 0x0;
		break;
	}
	case 6: {
		lcr = (stopbits == 2) ? 0x5 : 0x1;
		break;
	}
	case 7: {
		lcr = (stopbits == 2) ? 0x6 : 0x2;
		break;
	}
	default: { /* 8 databits */
		lcr                 = (stopbits == 2) ? 0x7 : 0x3;
		this_uart->databits = 8;
		break;
	}
	}

	/* parity control */
	if (parity_en == 1) {
		if (even_odd == 1) {
			lcr |= 0x18;
		} else {
			lcr |= 0x8;
		}
	}
	dev->lcr = lcr;

	/* all done */
	return 0;
}

/*
 ***************************************************************
 * Changes baudrate.
 * NOTE: User must make sure the baudrate passed is correct.
 ***************************************************************
 */
uint8_t uart_set_rate(struct uart_instance *this_uart, uint32_t baudrate)
{
	uint32_t divisor;
	if (NULL == this_uart) {
		return 1;
	}
	volatile struct uart_dev *dev;
	dev = (volatile struct uart_dev *)(this_uart->base);

	/* it would be nice to have uart stop-receiver/stop-transmitter
	 * functionality! */
	/* the only check we do is for zero (to avoid divide-by-zero) */
	if (baudrate == 0) {
		return (UART_ERR_INVALID_ARGUMENT);
	}

#ifndef _UART_NO_INTERRUPTS_
	/* disable interrupt for the UART */
	pic_int_disable(this_uart->intrLevel);
#endif

	/* set to new baudrate */
	this_uart->baudrate = baudrate;

	/* Calculate clock-divisor */
	divisor             = (this_uart->sys_clk) / baudrate;

	/*
	 * Setup uart:
	 * - divisor
	 */
	uint32_t *address   = (uint32_t *)&(dev->dlr_lsb);
	*address            = (uint8_t)(divisor);
	address++;
	*address = (uint8_t)(divisor >> 8);

#ifndef _UART_NO_INTERRUPTS_
	/* re-enable interrupt for the UART */
	pic_int_enable(this_uart->intrLevel);
#endif

	return 0;
}
